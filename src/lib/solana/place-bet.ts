/**
 * Prediction/Bet placement using MagicBlock delegation + Privy signing
 * 
 * Flow:
 * 1. Frontend: User sets prediction & amount (slider + input)
 * 2. Frontend: Create bet account (init_bet on-chain via Privy signed tx)
 * 3. Frontend: Delegate transaction to TEE using MagicBlock SDK
 * 4. TEE: Executes place_bet instruction in ephemeral environment
 * 5. Backend: Save bet metadata to database (poolId, userId, etc.)
 */

import { PublicKey, Transaction, SystemProgram, Keypair, LAMPORTS_PER_SOL } from "@solana/web3.js"
import { 
  permissionPdaFromAccount,
  delegationRecordPdaFromDelegatedAccount,
  delegationMetadataPdaFromDelegatedAccount,
  delegateBufferPdaFromDelegatedAccountAndOwnerProgram,
} from "@magicblock-labs/ephemeral-rollups-sdk"
import { placePrediction, claimReward } from "@/lib/api/predictions"
import type { Prediction } from "@/lib/types/models"

export interface PlaceBetParams {
  poolId: string
  poolPubkey: PublicKey
  predictedPrice: number // Value to predict (within min/max range)
  stakeAmount: number // In lamports or token base units
  userWallet: PublicKey
  tokenAccountAddress: PublicKey
  signTransaction: (tx: Transaction) => Promise<Transaction> // Privy signer
}

export interface InitBetParams {
  poolId: string
  poolPubkey: PublicKey
  userWallet: PublicKey
  tokenAccountAddress: PublicKey
  amount: number // Deposit amount
  requestId: string // Unique request ID for bet PDA seed
  signTransaction: (tx: Transaction) => Promise<Transaction>
}

export interface ClaimRewardsParams {
  predictionId: string
}

/**
 * STEP 1: Initialize bet on-chain (L1 transaction)
 * - Creates UserBet account with Initialized status
 * - Transfers tokens to pool vault
 * - Uses Privy to sign transaction
 */
export async function initializeBetOnChain(params: InitBetParams): Promise<{
  betPubkey: PublicKey
  requestId: string
  txSignature: string
}> {
  try {
    console.log("[initializeBetOnChain] Creating bet account...")
    
    // Generate unique request ID if not provided
    const requestId = params.requestId || `req_${Date.now()}_${Math.random().toString(36).slice(2, 9)}`
    
    // TODO: Build init_bet instruction using Anchor
    // This will:
    // - Create UserBet PDA account
    // - Transfer tokens from user to pool vault
    // - Set BetStatus to Initialized
    
    // For now, return mock response - actual implementation depends on IDL
    const betPubkey = Keypair.generate().publicKey
    
    // Sign and send transaction via Privy
    // const tx = new Transaction().add(initBetInstruction)
    // const signedTx = await params.signTransaction(tx)
    // const txSignature = await connection.sendRawTransaction(signedTx.serialize())
    
    console.log("[initializeBetOnChain] Bet initialized:", betPubkey.toString())
    
    return {
      betPubkey,
      requestId,
      txSignature: "mock_signature", // Replace with actual signature
    }
  } catch (error) {
    console.error("[initializeBetOnChain] Failed to initialize bet:", error)
    throw error
  }
}

/**
 * STEP 2: Delegate to TEE for encrypted prediction placement
 * - Uses MagicBlock SDK to create delegation record
 * - TEE executes place_bet instruction with encrypted prediction
 * - No user signature required for this step (TEE operates independently)
 */
export async function delegateTeeExecution(params: {
  userWallet: PublicKey
  betPubkey: PublicKey
  prediction: number
  requestId: string
}): Promise<{
  delegationRecord: PublicKey
  ephemeralSigner: PublicKey
}> {
  try {
    console.log("[delegateTeeExecution] Setting up TEE delegation...")
    
    // Calculate delegation PDAs using MagicBlock SDK
    const permissionPda = permissionPdaFromAccount(params.userWallet)
    const delegationRecord = delegationRecordPdaFromDelegatedAccount(params.betPubkey)
    const delegationMetadata = delegationMetadataPdaFromDelegatedAccount(params.betPubkey)
    
    // In real implementation:
    // 1. Create delegation instruction
    // 2. Sign with user (via Privy)
    // 3. Submit to ephemeral RPC endpoint
    // 4. TEE executes place_bet in isolated environment
    
    console.log("[delegateTeeExecution] Delegation PDAs:")
    console.log("  - Permission PDA:", permissionPda.toString())
    console.log("  - Delegation Record:", delegationRecord.toString())
    console.log("  - Delegation Metadata:", delegationMetadata.toString())
    
    // Ephemeral signer is generated by TEE
    const ephemeralSigner = Keypair.generate().publicKey
    
    return {
      delegationRecord,
      ephemeralSigner,
    }
  } catch (error) {
    console.error("[delegateTeeExecution] Failed to delegate to TEE:", error)
    throw error
  }
}

/**
 * STEP 3: Save bet metadata to database
 * - Called after successful TEE execution
 * - Stores poolId, userId, prediction details for future queries
 */
export async function saveBetMetadata(params: {
  poolId: string
  userWallet: string
  betPubkey: PublicKey
  deposit: number
  prediction: number
  requestId: string
}): Promise<Prediction> {
  try {
    console.log("[saveBetMetadata] Saving bet to database...")
    
    const prediction = await placePrediction({
      poolId: params.poolId,
      userWallet: params.userWallet,
      deposit: params.deposit,
      prediction: params.prediction,
      requestId: params.requestId,
      bet_pubkey: params.betPubkey.toString(),
    })
    
    console.log("[saveBetMetadata] Bet saved successfully:", prediction.id)
    return prediction
  } catch (error) {
    console.error("[saveBetMetadata] Failed to save bet metadata:", error)
    throw error
  }
}

/**
 * Full bet placement flow (combines all 3 steps)
 * Called from frontend component (InlineBettingPanel)
 * 
 * Flow:
 * 1. Initialize bet on L1 (user signature via Privy)
 * 2. Delegate to TEE for encrypted prediction storage
 * 3. Save metadata to database
 */
export async function placeEncryptedBet(params: PlaceBetParams): Promise<Prediction> {
  try {
    console.log("[placeEncryptedBet] Starting full bet placement flow...")
    
    const requestId = `req_${Date.now()}_${Math.random().toString(36).slice(2, 9)}`
    
    // STEP 1: Initialize bet on-chain
    console.log("[placeEncryptedBet] Step 1: Initialize bet on-chain")
    const { betPubkey } = await initializeBetOnChain({
      poolId: params.poolId,
      poolPubkey: params.poolPubkey,
      userWallet: params.userWallet,
      tokenAccountAddress: params.tokenAccountAddress,
      amount: params.stakeAmount,
      requestId,
      signTransaction: params.signTransaction,
    })
    
    // STEP 2: Delegate to TEE
    console.log("[placeEncryptedBet] Step 2: Delegate to TEE")
    await delegateTeeExecution({
      userWallet: params.userWallet,
      betPubkey,
      prediction: params.predictedPrice,
      requestId,
    })
    
    // STEP 3: Save metadata to database
    console.log("[placeEncryptedBet] Step 3: Save metadata to database")
    const savedPrediction = await saveBetMetadata({
      poolId: params.poolId,
      userWallet: params.userWallet.toString(),
      betPubkey,
      deposit: params.stakeAmount,
      prediction: params.predictedPrice,
      requestId,
    })
    
    console.log("[placeEncryptedBet] Full flow completed successfully!")
    return savedPrediction
  } catch (error) {
    console.error("[placeEncryptedBet] Failed to place encrypted bet:", error)
    throw error
  }
}

/**
 * Claim reward for a prediction
 */
export async function claimPredictionReward(
  params: ClaimRewardsParams,
): Promise<Prediction> {
  try {
    console.log("[claimPredictionReward] Claiming reward for prediction:", params.predictionId)

    const updatedPrediction = await claimReward(params.predictionId)

    console.log("[claimPredictionReward] Reward claimed successfully")
    return updatedPrediction
  } catch (error) {
    console.error("[claimPredictionReward] Failed to claim reward:", error)
    throw error
  }
}